import{l as at}from"./level-supports-DNzhSreG.js";import{l as yt}from"./level-transcoder-A_kVx6L3.js";import{e as Et}from"./events-CXH2uRM3.js";import{c as Ue}from"./catering-DDE1aTSv.js";import{m as J}from"./module-error-Ch16hYGc.js";import{q as gt}from"./queue-microtask-Gk9fBIqQ.js";import{b as mt}from"./buffer-EBb79ogF.js";var oe={},Te={},V={},ye={};ye.getCallback=function(o,e){return typeof o=="function"?o:e};ye.getOptions=function(o,e){return typeof o=="object"&&o!==null?o:e!==void 0?e:{}};const{fromCallback:ke}=Ue,w=J,{getOptions:Ve,getCallback:Xe}=ye,F=Symbol("promise"),Q=Symbol("callback"),S=Symbol("working"),W=Symbol("handleOne"),D=Symbol("handleMany"),Ce=Symbol("autoClose"),P=Symbol("finishWork"),k=Symbol("returnMany"),K=Symbol("closing"),he=Symbol("handleClose"),Ee=Symbol("closed"),ce=Symbol("closeCallbacks"),M=Symbol("keyEncoding"),X=Symbol("valueEncoding"),Ne=Symbol("abortOnClose"),ge=Symbol("legacy"),De=Symbol("keys"),Ke=Symbol("values"),R=Symbol("limit"),I=Symbol("count"),me=Object.freeze({}),_t=()=>{};let Je=!1;class He{constructor(e,t,n){if(typeof e!="object"||e===null){const s=e===null?"null":typeof e;throw new TypeError(`The first argument must be an abstract-level database, received ${s}`)}if(typeof t!="object"||t===null)throw new TypeError("The second argument must be an options object");this[Ee]=!1,this[ce]=[],this[S]=!1,this[K]=!1,this[Ce]=!1,this[Q]=null,this[W]=this[W].bind(this),this[D]=this[D].bind(this),this[he]=this[he].bind(this),this[M]=t[M],this[X]=t[X],this[ge]=n,this[R]=Number.isInteger(t.limit)&&t.limit>=0?t.limit:1/0,this[I]=0,this[Ne]=!!t.abortOnClose,this.db=e,this.db.attachResource(this),this.nextTick=e.nextTick}get count(){return this[I]}get limit(){return this[R]}next(e){let t;if(e===void 0)t=new Promise((n,s)=>{e=(r,u,h)=>{r?s(r):this[ge]?u===void 0&&h===void 0?n():n([u,h]):n(u)}});else if(typeof e!="function")throw new TypeError("Callback must be a function");return this[K]?this.nextTick(e,new w("Iterator is not open: cannot call next() after close()",{code:"LEVEL_ITERATOR_NOT_OPEN"})):this[S]?this.nextTick(e,new w("Iterator is busy: cannot call next() until previous call has completed",{code:"LEVEL_ITERATOR_BUSY"})):(this[S]=!0,this[Q]=e,this[I]>=this[R]?this.nextTick(this[W],null):this._next(this[W])),t}_next(e){this.nextTick(e)}nextv(e,t,n){return n=Xe(t,n),n=ke(n,F),t=Ve(t,me),Number.isInteger(e)?(this[K]?this.nextTick(n,new w("Iterator is not open: cannot call nextv() after close()",{code:"LEVEL_ITERATOR_NOT_OPEN"})):this[S]?this.nextTick(n,new w("Iterator is busy: cannot call nextv() until previous call has completed",{code:"LEVEL_ITERATOR_BUSY"})):(e<1&&(e=1),this[R]<1/0&&(e=Math.min(e,this[R]-this[I])),this[S]=!0,this[Q]=n,e<=0?this.nextTick(this[D],null,[]):this._nextv(e,t,this[D])),n[F]):(this.nextTick(n,new TypeError("The first argument 'size' must be an integer")),n[F])}_nextv(e,t,n){const s=[],r=(u,h,d)=>{if(u)return n(u);if(this[ge]?h===void 0&&d===void 0:h===void 0)return n(null,s);s.push(this[ge]?[h,d]:h),s.length===e?n(null,s):this._next(r)};this._next(r)}all(e,t){return t=Xe(e,t),t=ke(t,F),e=Ve(e,me),this[K]?this.nextTick(t,new w("Iterator is not open: cannot call all() after close()",{code:"LEVEL_ITERATOR_NOT_OPEN"})):this[S]?this.nextTick(t,new w("Iterator is busy: cannot call all() until previous call has completed",{code:"LEVEL_ITERATOR_BUSY"})):(this[S]=!0,this[Q]=t,this[Ce]=!0,this[I]>=this[R]?this.nextTick(this[D],null,[]):this._all(e,this[D])),t[F]}_all(e,t){let n=this[I];const s=[],r=()=>{const h=this[R]<1/0?Math.min(1e3,this[R]-n):1e3;h<=0?this.nextTick(t,null,s):this._nextv(h,me,u)},u=(h,d)=>{h?t(h):d.length===0?t(null,s):(s.push.apply(s,d),n+=d.length,r())};r()}[P](){const e=this[Q];return this[Ne]&&e===null?_t:(this[S]=!1,this[Q]=null,this[K]&&this._close(this[he]),e)}[k](e,t,n){this[Ce]?this.close(e.bind(null,t,n)):e(t,n)}seek(e,t){if(t=Ve(t,me),!this[K]){if(this[S])throw new w("Iterator is busy: cannot call seek() until next() has completed",{code:"LEVEL_ITERATOR_BUSY"});{const n=this.db.keyEncoding(t.keyEncoding||this[M]),s=n.format;t.keyEncoding!==s&&(t={...t,keyEncoding:s});const r=this.db.prefixKey(n.encode(e),s);this._seek(r,t)}}}_seek(e,t){throw new w("Iterator does not support seek()",{code:"LEVEL_NOT_SUPPORTED"})}close(e){return e=ke(e,F),this[Ee]?this.nextTick(e):this[K]?this[ce].push(e):(this[K]=!0,this[ce].push(e),this[S]?this[Ne]&&this[P]()(new w("Aborted on iterator close()",{code:"LEVEL_ITERATOR_NOT_OPEN"})):this._close(this[he])),e[F]}_close(e){this.nextTick(e)}[he](){this[Ee]=!0,this.db.detachResource(this);const e=this[ce];this[ce]=[];for(const t of e)t()}async*[Symbol.asyncIterator](){try{let e;for(;(e=await this.next())!==void 0;)yield e}finally{this[Ee]||await this.close()}}}let we=class extends He{constructor(e,t){super(e,t,!0),this[De]=t.keys!==!1,this[Ke]=t.values!==!1}[W](e,t,n){const s=this[P]();if(e)return s(e);try{t=this[De]&&t!==void 0?this[M].decode(t):void 0,n=this[Ke]&&n!==void 0?this[X].decode(n):void 0}catch(r){return s(new ie("entry",r))}t===void 0&&n===void 0||this[I]++,s(null,t,n)}[D](e,t){const n=this[P]();if(e)return this[k](n,e);try{for(const s of t){const r=s[0],u=s[1];s[0]=this[De]&&r!==void 0?this[M].decode(r):void 0,s[1]=this[Ke]&&u!==void 0?this[X].decode(u):void 0}}catch(s){return this[k](n,new ie("entries",s))}this[I]+=t.length,this[k](n,null,t)}end(e){return!Je&&typeof console<"u"&&(Je=!0,console.warn(new w("The iterator.end() method was renamed to close() and end() is an alias that will be removed in a future version",{code:"LEVEL_LEGACY"}))),this.close(e)}},pt=class extends He{constructor(e,t){super(e,t,!1)}[W](e,t){const n=this[P]();if(e)return n(e);try{t=t!==void 0?this[M].decode(t):void 0}catch(s){return n(new ie("key",s))}t!==void 0&&this[I]++,n(null,t)}[D](e,t){const n=this[P]();if(e)return this[k](n,e);try{for(let s=0;s<t.length;s++){const r=t[s];t[s]=r!==void 0?this[M].decode(r):void 0}}catch(s){return this[k](n,new ie("keys",s))}this[I]+=t.length,this[k](n,null,t)}},bt=class extends He{constructor(e,t){super(e,t,!1)}[W](e,t){const n=this[P]();if(e)return n(e);try{t=t!==void 0?this[X].decode(t):void 0}catch(s){return n(new ie("value",s))}t!==void 0&&this[I]++,n(null,t)}[D](e,t){const n=this[P]();if(e)return this[k](n,e);try{for(let s=0;s<t.length;s++){const r=t[s];t[s]=r!==void 0?this[X].decode(r):void 0}}catch(s){return this[k](n,new ie("values",s))}this[I]+=t.length,this[k](n,null,t)}};class ie extends w{constructor(e,t){super(`Iterator could not decode ${e}`,{code:"LEVEL_DECODE_ERROR",cause:t})}}for(const o of["_ended property","_nexting property","_end method"])Object.defineProperty(we.prototype,o.split(" ")[0],{get(){throw new w(`The ${o} has been removed`,{code:"LEVEL_LEGACY"})},set(){throw new w(`The ${o} has been removed`,{code:"LEVEL_LEGACY"})}});we.keyEncoding=M;we.valueEncoding=X;V.AbstractIterator=we;V.AbstractKeyIterator=pt;V.AbstractValueIterator=bt;var Ye={};const{AbstractKeyIterator:vt,AbstractValueIterator:xt}=V,G=Symbol("iterator"),ue=Symbol("callback"),re=Symbol("handleOne"),z=Symbol("handleMany");let je=class extends vt{constructor(e,t){super(e,t),this[G]=e.iterator({...t,keys:!0,values:!1}),this[re]=this[re].bind(this),this[z]=this[z].bind(this)}},rt=class extends xt{constructor(e,t){super(e,t),this[G]=e.iterator({...t,keys:!1,values:!0}),this[re]=this[re].bind(this),this[z]=this[z].bind(this)}};for(const o of[je,rt]){const e=o===je,t=e?n=>n[0]:n=>n[1];o.prototype._next=function(n){this[ue]=n,this[G].next(this[re])},o.prototype[re]=function(n,s,r){const u=this[ue];n?u(n):u(null,e?s:r)},o.prototype._nextv=function(n,s,r){this[ue]=r,this[G].nextv(n,s,this[z])},o.prototype._all=function(n,s){this[ue]=s,this[G].all(n,this[z])},o.prototype[z]=function(n,s){const r=this[ue];n?r(n):r(null,s.map(t))},o.prototype._seek=function(n,s){this[G].seek(n,s)},o.prototype._close=function(n){this[G].close(n)}}Ye.DefaultKeyIterator=je;Ye.DefaultValueIterator=rt;var Ae={};const{AbstractIterator:Tt,AbstractKeyIterator:wt,AbstractValueIterator:At}=V,Re=J,T=Symbol("nut"),Ie=Symbol("undefer"),Le=Symbol("factory");let ot=class extends Tt{constructor(e,t){super(e,t),this[T]=null,this[Le]=()=>e.iterator(t),this.db.defer(()=>this[Ie]())}},ht=class extends wt{constructor(e,t){super(e,t),this[T]=null,this[Le]=()=>e.keys(t),this.db.defer(()=>this[Ie]())}},ct=class extends At{constructor(e,t){super(e,t),this[T]=null,this[Le]=()=>e.values(t),this.db.defer(()=>this[Ie]())}};for(const o of[ot,ht,ct])o.prototype[Ie]=function(){this.db.status==="open"&&(this[T]=this[Le]())},o.prototype._next=function(e){this[T]!==null?this[T].next(e):this.db.status==="opening"?this.db.defer(()=>this._next(e)):this.nextTick(e,new Re("Iterator is not open: cannot call next() after close()",{code:"LEVEL_ITERATOR_NOT_OPEN"}))},o.prototype._nextv=function(e,t,n){this[T]!==null?this[T].nextv(e,t,n):this.db.status==="opening"?this.db.defer(()=>this._nextv(e,t,n)):this.nextTick(n,new Re("Iterator is not open: cannot call nextv() after close()",{code:"LEVEL_ITERATOR_NOT_OPEN"}))},o.prototype._all=function(e,t){this[T]!==null?this[T].all(t):this.db.status==="opening"?this.db.defer(()=>this._all(e,t)):this.nextTick(t,new Re("Iterator is not open: cannot call all() after close()",{code:"LEVEL_ITERATOR_NOT_OPEN"}))},o.prototype._seek=function(e,t){this[T]!==null?this[T]._seek(e,t):this.db.status==="opening"&&this.db.defer(()=>this._seek(e,t))},o.prototype._close=function(e){this[T]!==null?this[T].close(e):this.db.status==="opening"?this.db.defer(()=>this._close(e)):this.nextTick(e)};Ae.DeferredIterator=ot;Ae.DeferredKeyIterator=ht;Ae.DeferredValueIterator=ct;var ut={},qe={};const{fromCallback:Qe}=Ue,_e=J,{getCallback:It,getOptions:Lt}=ye,pe=Symbol("promise"),A=Symbol("status"),Z=Symbol("operations"),de=Symbol("finishClose"),ee=Symbol("closeCallbacks");let Ot=class{constructor(e){if(typeof e!="object"||e===null){const t=e===null?"null":typeof e;throw new TypeError(`The first argument must be an abstract-level database, received ${t}`)}this[Z]=[],this[ee]=[],this[A]="open",this[de]=this[de].bind(this),this.db=e,this.db.attachResource(this),this.nextTick=e.nextTick}get length(){return this[Z].length}put(e,t,n){if(this[A]!=="open")throw new _e("Batch is not open: cannot call put() after write() or close()",{code:"LEVEL_BATCH_NOT_OPEN"});const s=this.db._checkKey(e)||this.db._checkValue(t);if(s)throw s;const r=n&&n.sublevel!=null?n.sublevel:this.db,u=n,h=r.keyEncoding(n&&n.keyEncoding),d=r.valueEncoding(n&&n.valueEncoding),c=h.format;n={...n,keyEncoding:c,valueEncoding:d.format},r!==this.db&&(n.sublevel=null);const m=r.prefixKey(h.encode(e),c),E=d.encode(t);return this._put(m,E,n),this[Z].push({...u,type:"put",key:e,value:t}),this}_put(e,t,n){}del(e,t){if(this[A]!=="open")throw new _e("Batch is not open: cannot call del() after write() or close()",{code:"LEVEL_BATCH_NOT_OPEN"});const n=this.db._checkKey(e);if(n)throw n;const s=t&&t.sublevel!=null?t.sublevel:this.db,r=t,u=s.keyEncoding(t&&t.keyEncoding),h=u.format;return t={...t,keyEncoding:h},s!==this.db&&(t.sublevel=null),this._del(s.prefixKey(u.encode(e),h),t),this[Z].push({...r,type:"del",key:e}),this}_del(e,t){}clear(){if(this[A]!=="open")throw new _e("Batch is not open: cannot call clear() after write() or close()",{code:"LEVEL_BATCH_NOT_OPEN"});return this._clear(),this[Z]=[],this}_clear(){}write(e,t){return t=It(e,t),t=Qe(t,pe),e=Lt(e),this[A]!=="open"?this.nextTick(t,new _e("Batch is not open: cannot call write() after write() or close()",{code:"LEVEL_BATCH_NOT_OPEN"})):this.length===0?this.close(t):(this[A]="writing",this._write(e,n=>{this[A]="closing",this[ee].push(()=>t(n)),n||this.db.emit("batch",this[Z]),this._close(this[de])})),t[pe]}_write(e,t){}close(e){return e=Qe(e,pe),this[A]==="closing"?this[ee].push(e):this[A]==="closed"?this.nextTick(e):(this[ee].push(e),this[A]!=="writing"&&(this[A]="closing",this._close(this[de]))),e[pe]}_close(e){this.nextTick(e)}[de](){this[A]="closed",this.db.detachResource(this);const e=this[ee];this[ee]=[];for(const t of e)t()}};qe.AbstractChainedBatch=Ot;const{AbstractChainedBatch:St}=qe,kt=J,te=Symbol("encoded");let Vt=class extends St{constructor(e){super(e),this[te]=[]}_put(e,t,n){this[te].push({...n,type:"put",key:e,value:t})}_del(e,t){this[te].push({...t,type:"del",key:e})}_clear(){this[te]=[]}_write(e,t){this.db.status==="opening"?this.db.defer(()=>this._write(e,t)):this.db.status==="open"?this[te].length===0?this.nextTick(t):this.db._batch(this[te],e,t):this.nextTick(t,new kt("Batch is not open: cannot call write() after write() or close()",{code:"LEVEL_BATCH_NOT_OPEN"}))}};ut.DefaultChainedBatch=Vt;const Ze=J,Ct=Object.prototype.hasOwnProperty,Nt=new Set(["lt","lte","gt","gte"]);var Dt=function(o,e){const t={};for(const n in o)if(Ct.call(o,n)&&!(n==="keyEncoding"||n==="valueEncoding")){if(n==="start"||n==="end")throw new Ze(`The legacy range option '${n}' has been removed`,{code:"LEVEL_LEGACY"});if(n==="encoding")throw new Ze("The levelup-style 'encoding' alias has been removed, use 'valueEncoding' instead",{code:"LEVEL_LEGACY"});Nt.has(n)?t[n]=e.encode(o[n]):t[n]=o[n]}return t.reverse=!!t.reverse,t.limit=Number.isInteger(t.limit)&&t.limit>=0?t.limit:-1,t},$e,et;function Kt(){if(et)return $e;et=1;const o=gt;return $e=function(e,...t){t.length===0?o(e):o(()=>e(...t))},$e}var le={},tt;function Rt(){if(tt)return le;tt=1;const{AbstractIterator:o,AbstractKeyIterator:e,AbstractValueIterator:t}=V,n=Symbol("unfix"),s=Symbol("iterator"),r=Symbol("handleOne"),u=Symbol("handleMany"),h=Symbol("callback");class d extends o{constructor(l,f,_,b){super(l,f),this[s]=_,this[n]=b,this[r]=this[r].bind(this),this[u]=this[u].bind(this),this[h]=null}[r](l,f,_){const b=this[h];if(l)return b(l);f!==void 0&&(f=this[n](f)),b(l,f,_)}[u](l,f){const _=this[h];if(l)return _(l);for(const b of f){const j=b[0];j!==void 0&&(b[0]=this[n](j))}_(l,f)}}class c extends e{constructor(l,f,_,b){super(l,f),this[s]=_,this[n]=b,this[r]=this[r].bind(this),this[u]=this[u].bind(this),this[h]=null}[r](l,f){const _=this[h];if(l)return _(l);f!==void 0&&(f=this[n](f)),_(l,f)}[u](l,f){const _=this[h];if(l)return _(l);for(let b=0;b<f.length;b++){const j=f[b];j!==void 0&&(f[b]=this[n](j))}_(l,f)}}class m extends t{constructor(l,f,_){super(l,f),this[s]=_}}for(const E of[d,c])E.prototype._next=function(l){this[h]=l,this[s].next(this[r])},E.prototype._nextv=function(l,f,_){this[h]=_,this[s].nextv(l,f,this[u])},E.prototype._all=function(l,f){this[h]=f,this[s].all(l,this[u])};for(const E of[m])E.prototype._next=function(l){this[s].next(l)},E.prototype._nextv=function(l,f,_){this[s].nextv(l,f,_)},E.prototype._all=function(l,f){this[s].all(l,f)};for(const E of[d,c,m])E.prototype._seek=function(l,f){this[s].seek(l,f)},E.prototype._close=function(l){this[s].close(l)};return le.AbstractSublevelIterator=d,le.AbstractSublevelKeyIterator=c,le.AbstractSublevelValueIterator=m,le}var Be,nt;function $t(){if(nt)return Be;nt=1;const o=J,{Buffer:e}=mt||{},{AbstractSublevelIterator:t,AbstractSublevelKeyIterator:n,AbstractSublevelValueIterator:s}=Rt(),r=Symbol("prefix"),u=Symbol("upperBound"),h=Symbol("prefixRange"),d=Symbol("parent"),c=Symbol("unfix"),m=new TextEncoder,E={separator:"!"};Be=function({AbstractLevel:x}){class v extends x{static defaults(i){if(typeof i=="string")throw new o("The subleveldown string shorthand for { separator } has been removed",{code:"LEVEL_LEGACY"});if(i&&i.open)throw new o("The subleveldown open option has been removed",{code:"LEVEL_LEGACY"});return i==null?E:i.separator?i:{...i,separator:"!"}}constructor(i,y,p){const{separator:O,manifest:dt,...lt}=v.defaults(p);y=j(y,O);const Oe=O.charCodeAt(0)+1,Se=i[d]||i;if(!m.encode(y).every(ze=>ze>Oe&&ze<127))throw new o(`Prefix must use bytes > ${Oe} < 127`,{code:"LEVEL_INVALID_PREFIX"});super(l(Se,dt),lt);const We=(i.prefix||"")+O+y+O,ft=We.slice(0,-1)+String.fromCharCode(Oe);this[d]=Se,this[r]=new _(We),this[u]=new _(ft),this[c]=new b,this.nextTick=Se.nextTick}prefixKey(i,y){if(y==="utf8")return this[r].utf8+i;if(i.byteLength===0)return this[r][y];if(y==="view"){const p=this[r].view,O=new Uint8Array(p.byteLength+i.byteLength);return O.set(p,0),O.set(i,p.byteLength),O}else{const p=this[r].buffer;return e.concat([p,i],p.byteLength+i.byteLength)}}[h](i,y){i.gte!==void 0?i.gte=this.prefixKey(i.gte,y):i.gt!==void 0?i.gt=this.prefixKey(i.gt,y):i.gte=this[r][y],i.lte!==void 0?i.lte=this.prefixKey(i.lte,y):i.lt!==void 0?i.lt=this.prefixKey(i.lt,y):i.lte=this[u][y]}get prefix(){return this[r].utf8}get db(){return this[d]}_open(i,y){this[d].open({passive:!0},y)}_put(i,y,p,O){this[d].put(i,y,p,O)}_get(i,y,p){this[d].get(i,y,p)}_getMany(i,y,p){this[d].getMany(i,y,p)}_del(i,y,p){this[d].del(i,y,p)}_batch(i,y,p){this[d].batch(i,y,p)}_clear(i,y){this[h](i,i.keyEncoding),this[d].clear(i,y)}_iterator(i){this[h](i,i.keyEncoding);const y=this[d].iterator(i),p=this[c].get(this[r].utf8.length,i.keyEncoding);return new t(this,i,y,p)}_keys(i){this[h](i,i.keyEncoding);const y=this[d].keys(i),p=this[c].get(this[r].utf8.length,i.keyEncoding);return new n(this,i,y,p)}_values(i){this[h](i,i.keyEncoding);const y=this[d].values(i);return new s(this,i,y)}}return{AbstractSublevel:v}};const l=function(x,v){return{...x.supports,createIfMissing:!1,errorIfExists:!1,events:{},additionalMethods:{},...v,encodings:{utf8:f(x,"utf8"),buffer:f(x,"buffer"),view:f(x,"view")}}},f=function(x,v){return x.supports.encodings[v]?x.keyEncoding(v).name===v:!1};class _{constructor(v){this.utf8=v,this.view=m.encode(v),this.buffer=e?e.from(this.view.buffer,0,this.view.byteLength):{}}}class b{constructor(){this.cache=new Map}get(v,C){let i=this.cache.get(C);return i===void 0&&(C==="view"?i=(function(y,p){return p.subarray(y)}).bind(null,v):i=(function(y,p){return p.slice(y)}).bind(null,v),this.cache.set(C,i)),i}}const j=function(x,v){let C=0,i=x.length;for(;C<i&&x[C]===v;)C++;for(;i>C&&x[i-1]===v;)i--;return x.slice(C,i)};return Be}const{supports:Bt}=at,{Transcoder:Mt}=yt,{EventEmitter:Pt}=Et,{fromCallback:$}=Ue,L=J,{AbstractIterator:U}=V,{DefaultKeyIterator:jt,DefaultValueIterator:Ft}=Ye,{DeferredIterator:Ut,DeferredKeyIterator:Ht,DeferredValueIterator:Yt}=Ae,{DefaultChainedBatch:st}=ut,{getCallback:H,getOptions:B}=ye,be=Dt,a=Symbol("promise"),N=Symbol("landed"),Y=Symbol("resources"),Me=Symbol("closeResources"),fe=Symbol("operations"),ae=Symbol("undefer"),ve=Symbol("deferOpen"),it=Symbol("options"),g=Symbol("status"),q=Symbol("defaultOptions"),ne=Symbol("transcoder"),xe=Symbol("keyEncoding"),Pe=Symbol("valueEncoding"),qt=()=>{};class Ge extends Pt{constructor(e,t){if(super(),typeof e!="object"||e===null)throw new TypeError("The first argument 'manifest' must be an object");t=B(t);const{keyEncoding:n,valueEncoding:s,passive:r,...u}=t;this[Y]=new Set,this[fe]=[],this[ve]=!0,this[it]=u,this[g]="opening",this.supports=Bt(e,{status:!0,promises:!0,clear:!0,getMany:!0,deferredOpen:!0,snapshots:e.snapshots!==!1,permanence:e.permanence!==!1,keyIterator:!0,valueIterator:!0,iteratorNextv:!0,iteratorAll:!0,encodings:e.encodings||{},events:Object.assign({},e.events,{opening:!0,open:!0,closing:!0,closed:!0,put:!0,del:!0,batch:!0,clear:!0})}),this[ne]=new Mt(Gt(this)),this[xe]=this[ne].encoding(n||"utf8"),this[Pe]=this[ne].encoding(s||"utf8");for(const h of this[ne].encodings())this.supports.encodings[h.commonName]||(this.supports.encodings[h.commonName]=!0);this[q]={empty:Object.freeze({}),entry:Object.freeze({keyEncoding:this[xe].commonName,valueEncoding:this[Pe].commonName}),key:Object.freeze({keyEncoding:this[xe].commonName})},this.nextTick(()=>{this[ve]&&this.open({passive:!1},qt)})}get status(){return this[g]}keyEncoding(e){return this[ne].encoding(e??this[xe])}valueEncoding(e){return this[ne].encoding(e??this[Pe])}open(e,t){t=H(e,t),t=$(t,a),e={...this[it],...B(e)},e.createIfMissing=e.createIfMissing!==!1,e.errorIfExists=!!e.errorIfExists;const n=s=>{this[g]==="closing"||this[g]==="opening"?this.once(N,s?()=>n(s):n):this[g]!=="open"?t(new L("Database is not open",{code:"LEVEL_DATABASE_NOT_OPEN",cause:s})):t()};return e.passive?this[g]==="opening"?this.once(N,n):this.nextTick(n):this[g]==="closed"||this[ve]?(this[ve]=!1,this[g]="opening",this.emit("opening"),this._open(e,s=>{if(s){this[g]="closed",this[Me](()=>{this.emit(N),n(s)}),this[ae]();return}this[g]="open",this[ae](),this.emit(N),this[g]==="open"&&this.emit("open"),this[g]==="open"&&this.emit("ready"),n()})):this[g]==="open"?this.nextTick(n):this.once(N,()=>this.open(e,t)),t[a]}_open(e,t){this.nextTick(t)}close(e){e=$(e,a);const t=n=>{this[g]==="opening"||this[g]==="closing"?this.once(N,n?t(n):t):this[g]!=="closed"?e(new L("Database is not closed",{code:"LEVEL_DATABASE_NOT_CLOSED",cause:n})):e()};if(this[g]==="open"){this[g]="closing",this.emit("closing");const n=s=>{this[g]="open",this[ae](),this.emit(N),t(s)};this[Me](()=>{this._close(s=>{if(s)return n(s);this[g]="closed",this[ae](),this.emit(N),this[g]==="closed"&&this.emit("closed"),t()})})}else this[g]==="closed"?this.nextTick(t):this.once(N,()=>this.close(e));return e[a]}[Me](e){if(this[Y].size===0)return this.nextTick(e);let t=this[Y].size,n=!0;const s=()=>{--t===0&&(n?this.nextTick(e):e())};for(const r of this[Y])r.close(s);n=!1,this[Y].clear()}_close(e){this.nextTick(e)}get(e,t,n){if(n=H(t,n),n=$(n,a),t=B(t,this[q].entry),this[g]==="opening")return this.defer(()=>this.get(e,t,n)),n[a];if(se(this,n))return n[a];const s=this._checkKey(e);if(s)return this.nextTick(n,s),n[a];const r=this.keyEncoding(t.keyEncoding),u=this.valueEncoding(t.valueEncoding),h=r.format,d=u.format;return(t.keyEncoding!==h||t.valueEncoding!==d)&&(t=Object.assign({},t,{keyEncoding:h,valueEncoding:d})),this._get(this.prefixKey(r.encode(e),h),t,(c,m)=>{if(c)return(c.code==="LEVEL_NOT_FOUND"||c.notFound||/NotFound/i.test(c))&&(c.code||(c.code="LEVEL_NOT_FOUND"),c.notFound||(c.notFound=!0),c.status||(c.status=404)),n(c);try{m=u.decode(m)}catch(E){return n(new L("Could not decode value",{code:"LEVEL_DECODE_ERROR",cause:E}))}n(null,m)}),n[a]}_get(e,t,n){this.nextTick(n,new Error("NotFound"))}getMany(e,t,n){if(n=H(t,n),n=$(n,a),t=B(t,this[q].entry),this[g]==="opening")return this.defer(()=>this.getMany(e,t,n)),n[a];if(se(this,n))return n[a];if(!Array.isArray(e))return this.nextTick(n,new TypeError("The first argument 'keys' must be an array")),n[a];if(e.length===0)return this.nextTick(n,null,[]),n[a];const s=this.keyEncoding(t.keyEncoding),r=this.valueEncoding(t.valueEncoding),u=s.format,h=r.format;(t.keyEncoding!==u||t.valueEncoding!==h)&&(t=Object.assign({},t,{keyEncoding:u,valueEncoding:h}));const d=new Array(e.length);for(let c=0;c<e.length;c++){const m=e[c],E=this._checkKey(m);if(E)return this.nextTick(n,E),n[a];d[c]=this.prefixKey(s.encode(m),u)}return this._getMany(d,t,(c,m)=>{if(c)return n(c);try{for(let E=0;E<m.length;E++)m[E]!==void 0&&(m[E]=r.decode(m[E]))}catch(E){return n(new L(`Could not decode one or more of ${m.length} value(s)`,{code:"LEVEL_DECODE_ERROR",cause:E}))}n(null,m)}),n[a]}_getMany(e,t,n){this.nextTick(n,null,new Array(e.length).fill(void 0))}put(e,t,n,s){if(s=H(n,s),s=$(s,a),n=B(n,this[q].entry),this[g]==="opening")return this.defer(()=>this.put(e,t,n,s)),s[a];if(se(this,s))return s[a];const r=this._checkKey(e)||this._checkValue(t);if(r)return this.nextTick(s,r),s[a];const u=this.keyEncoding(n.keyEncoding),h=this.valueEncoding(n.valueEncoding),d=u.format,c=h.format;(n.keyEncoding!==d||n.valueEncoding!==c)&&(n=Object.assign({},n,{keyEncoding:d,valueEncoding:c}));const m=this.prefixKey(u.encode(e),d),E=h.encode(t);return this._put(m,E,n,l=>{if(l)return s(l);this.emit("put",e,t),s()}),s[a]}_put(e,t,n,s){this.nextTick(s)}del(e,t,n){if(n=H(t,n),n=$(n,a),t=B(t,this[q].key),this[g]==="opening")return this.defer(()=>this.del(e,t,n)),n[a];if(se(this,n))return n[a];const s=this._checkKey(e);if(s)return this.nextTick(n,s),n[a];const r=this.keyEncoding(t.keyEncoding),u=r.format;return t.keyEncoding!==u&&(t=Object.assign({},t,{keyEncoding:u})),this._del(this.prefixKey(r.encode(e),u),t,h=>{if(h)return n(h);this.emit("del",e),n()}),n[a]}_del(e,t,n){this.nextTick(n)}batch(e,t,n){if(!arguments.length){if(this[g]==="opening")return new st(this);if(this[g]!=="open")throw new L("Database is not open",{code:"LEVEL_DATABASE_NOT_OPEN"});return this._chainedBatch()}if(typeof e=="function"?n=e:n=H(t,n),n=$(n,a),t=B(t,this[q].empty),this[g]==="opening")return this.defer(()=>this.batch(e,t,n)),n[a];if(se(this,n))return n[a];if(!Array.isArray(e))return this.nextTick(n,new TypeError("The first argument 'operations' must be an array")),n[a];if(e.length===0)return this.nextTick(n),n[a];const s=new Array(e.length),{keyEncoding:r,valueEncoding:u,...h}=t;for(let d=0;d<e.length;d++){if(typeof e[d]!="object"||e[d]===null)return this.nextTick(n,new TypeError("A batch operation must be an object")),n[a];const c=Object.assign({},e[d]);if(c.type!=="put"&&c.type!=="del")return this.nextTick(n,new TypeError("A batch operation must have a type property that is 'put' or 'del'")),n[a];const m=this._checkKey(c.key);if(m)return this.nextTick(n,m),n[a];const E=c.sublevel!=null?c.sublevel:this,l=E.keyEncoding(c.keyEncoding||r),f=l.format;if(c.key=E.prefixKey(l.encode(c.key),f),c.keyEncoding=f,c.type==="put"){const _=this._checkValue(c.value);if(_)return this.nextTick(n,_),n[a];const b=E.valueEncoding(c.valueEncoding||u);c.value=b.encode(c.value),c.valueEncoding=b.format}E!==this&&(c.sublevel=null),s[d]=c}return this._batch(s,h,d=>{if(d)return n(d);this.emit("batch",e),n()}),n[a]}_batch(e,t,n){this.nextTick(n)}sublevel(e,t){return this._sublevel(e,Fe.defaults(t))}_sublevel(e,t){return new Fe(this,e,t)}prefixKey(e,t){return e}clear(e,t){if(t=H(e,t),t=$(t,a),e=B(e,this[q].empty),this[g]==="opening")return this.defer(()=>this.clear(e,t)),t[a];if(se(this,t))return t[a];const n=e,s=this.keyEncoding(e.keyEncoding);return e=be(e,s),e.keyEncoding=s.format,e.limit===0?this.nextTick(t):this._clear(e,r=>{if(r)return t(r);this.emit("clear",n),t()}),t[a]}_clear(e,t){this.nextTick(t)}iterator(e){const t=this.keyEncoding(e&&e.keyEncoding),n=this.valueEncoding(e&&e.valueEncoding);if(e=be(e,t),e.keys=e.keys!==!1,e.values=e.values!==!1,e[U.keyEncoding]=t,e[U.valueEncoding]=n,e.keyEncoding=t.format,e.valueEncoding=n.format,this[g]==="opening")return new Ut(this,e);if(this[g]!=="open")throw new L("Database is not open",{code:"LEVEL_DATABASE_NOT_OPEN"});return this._iterator(e)}_iterator(e){return new U(this,e)}keys(e){const t=this.keyEncoding(e&&e.keyEncoding),n=this.valueEncoding(e&&e.valueEncoding);if(e=be(e,t),e[U.keyEncoding]=t,e[U.valueEncoding]=n,e.keyEncoding=t.format,e.valueEncoding=n.format,this[g]==="opening")return new Ht(this,e);if(this[g]!=="open")throw new L("Database is not open",{code:"LEVEL_DATABASE_NOT_OPEN"});return this._keys(e)}_keys(e){return new jt(this,e)}values(e){const t=this.keyEncoding(e&&e.keyEncoding),n=this.valueEncoding(e&&e.valueEncoding);if(e=be(e,t),e[U.keyEncoding]=t,e[U.valueEncoding]=n,e.keyEncoding=t.format,e.valueEncoding=n.format,this[g]==="opening")return new Yt(this,e);if(this[g]!=="open")throw new L("Database is not open",{code:"LEVEL_DATABASE_NOT_OPEN"});return this._values(e)}_values(e){return new Ft(this,e)}defer(e){if(typeof e!="function")throw new TypeError("The first argument must be a function");this[fe].push(e)}[ae](){if(this[fe].length===0)return;const e=this[fe];this[fe]=[];for(const t of e)t()}attachResource(e){if(typeof e!="object"||e===null||typeof e.close!="function")throw new TypeError("The first argument must be a resource object");this[Y].add(e)}detachResource(e){this[Y].delete(e)}_chainedBatch(){return new st(this)}_checkKey(e){if(e==null)return new L("Key cannot be null or undefined",{code:"LEVEL_INVALID_KEY"})}_checkValue(e){if(e==null)return new L("Value cannot be null or undefined",{code:"LEVEL_INVALID_VALUE"})}}Ge.prototype.nextTick=Kt();const{AbstractSublevel:Fe}=$t()({AbstractLevel:Ge});Te.AbstractLevel=Ge;Te.AbstractSublevel=Fe;const se=function(o,e){return o[g]!=="open"?(o.nextTick(e,new L("Database is not open",{code:"LEVEL_DATABASE_NOT_OPEN"})),!0):!1},Gt=function(o){return Object.keys(o.supports.encodings).filter(e=>!!o.supports.encodings[e])};oe.AbstractLevel=Te.AbstractLevel;oe.AbstractSublevel=Te.AbstractSublevel;oe.AbstractIterator=V.AbstractIterator;oe.AbstractKeyIterator=V.AbstractKeyIterator;oe.AbstractValueIterator=V.AbstractValueIterator;oe.AbstractChainedBatch=qe.AbstractChainedBatch;export{oe as a};
